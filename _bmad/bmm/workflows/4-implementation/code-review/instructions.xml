<workflow>
  <critical>The workflow execution engine is governed by: {project-root}/_bmad/core/tasks/workflow.xml</critical>
  <critical>You MUST have already loaded and processed: {installed_path}/workflow.yaml</critical>
  <critical>Communicate all responses in {communication_language} and language MUST be tailored to {user_skill_level}</critical>
  <critical>Generate all documents in {document_output_language}</critical>

  <critical>üî• YOU ARE AN ADVERSARIAL CODE REVIEWER - Find what's wrong or missing! üî•</critical>
  <critical>Your purpose: Validate story file claims against actual implementation</critical>
  <critical>Challenge everything: Are tasks marked [x] actually done? Are ACs really implemented?</critical>
  <critical>Find 3-10 specific issues in every review minimum - no lazy "looks good" reviews - YOU are so much better than the dev agent
    that wrote this slop</critical>
  <critical>Read EVERY file in the File List - verify implementation against story requirements</critical>
  <critical>Tasks marked complete but not done = CRITICAL finding</critical>
  <critical>Acceptance Criteria not implemented = HIGH severity finding</critical>
  <critical>Do not review files that are not part of the application's source code. Always exclude the _bmad/ and _bmad-output/ folders from the review AND from git-vs-File-List discrepancy checks. Always exclude IDE and CLI configuration folders like .cursor/ and .windsurf/ and .claude/</critical>


  <step n="1" goal="Load story and discover changes">
    <action>Use provided {{story_path}} or ask user which story file to review</action>
    <action>Read COMPLETE story file</action>
    <action>Set {{story_key}} = extracted key from filename (e.g., "1-2-user-authentication.md" ‚Üí "1-2-user-authentication") or story
      metadata</action>
    <action>Parse sections: Story, Acceptance Criteria, Tasks/Subtasks, Dev Agent Record ‚Üí File List, Change Log</action>

    <!-- Discover actual changes via git -->
    <action>Check if git repository detected in current directory</action>
    <check if="git repository exists">
      <action>Run `git status --porcelain` to find uncommitted changes</action>
      <action>Run `git diff --name-only` to see modified files</action>
      <action>Run `git diff --cached --name-only` to see staged files</action>
      <action>Compile list of actually changed files from git output</action>
    </check>

    <!-- Cross-reference story File List vs git reality -->
    <action>Compare story's Dev Agent Record ‚Üí File List with actual git changes</action>
    <action>Note discrepancies:
      - Files in git but not in story File List
      - Files in story File List but no git changes
      - Missing documentation of what was actually changed
    </action>

    <invoke-protocol name="discover_inputs" />
    <action>Load {project_context} for coding standards (if exists)</action>
  </step>

  <step n="2" goal="Build review attack plan">
    <action>Extract ALL Acceptance Criteria from story</action>
    <action>Extract ALL Tasks/Subtasks with completion status ([x] vs [ ])</action>
    <action>From Dev Agent Record ‚Üí File List, compile list of claimed changes</action>

    <action>Create review plan:
      1. **AC Validation**: Verify each AC is actually implemented
      2. **Task Audit**: Verify each [x] task is really done
      3. **Code Quality**: Security, performance, maintainability
      4. **Test Quality**: Real tests vs placeholder bullshit
    </action>
  </step>

  <step n="3" goal="Execute adversarial review">
    <critical>VALIDATE EVERY CLAIM - Check git reality vs story claims</critical>

    <!-- Git vs Story Discrepancies -->
    <!-- NOTE: Exclude _bmad/ and _bmad-output/ files from discrepancy checks.
         These are workflow-managed artifacts (sprint-status.yaml, template-requirements.md,
         story files) that are updated by the BMAD toolchain itself, not story deliverables.
         They follow the same policy as the review exclusion rule above. -->
    <action>Review git vs story File List discrepancies (exclude _bmad/ and _bmad-output/ paths from all checks):
      1. **Files changed but not in story File List** ‚Üí MEDIUM finding (incomplete documentation)
      2. **Story lists files but no git changes** ‚Üí HIGH finding (false claims)
      3. **Uncommitted changes not documented** ‚Üí MEDIUM finding (transparency issue)
    </action>

    <!-- Poetry lock file staleness check (CRITICAL - causes CI failures) -->
    <check if="pyproject.toml is in story File List OR was found in git changes">
      <action>Check if poetry.lock is also in story File List or git changes</action>
      <check if="poetry.lock NOT in story File List AND NOT in git changes">
        <action>Flag as HIGH finding: "pyproject.toml modified but poetry.lock not updated ‚Äî will cause CI failure"</action>
        <action>Include fix instructions: Run `POETRY_VIRTUALENVS_CREATE=false conda run -n ncaa_eval poetry lock` (Poetry 2.x; no --no-update flag)</action>
      </check>
      <check if="code-review agent itself modified pyproject.toml during fixes">
        <critical>YOU must run `POETRY_VIRTUALENVS_CREATE=false conda run -n ncaa_eval poetry lock` before committing your fixes</critical>
        <action>Run poetry lock and stage poetry.lock with the fix commit</action>
        <action>Include poetry.lock in the review commit's staged files</action>
      </check>
    </check>

    <!-- Use combined file list: story File List + git discovered files -->
    <action>Create comprehensive review file list from story File List and git changes</action>

    <!-- AC Validation -->
    <action>For EACH Acceptance Criterion:
      1. Read the AC requirement
      2. Search implementation files for evidence
      3. Determine: IMPLEMENTED, PARTIAL, or MISSING
      4. If MISSING/PARTIAL ‚Üí HIGH SEVERITY finding
    </action>

    <!-- Task Completion Audit -->
    <action>For EACH task marked [x]:
      1. Read the task description
      2. Search files for evidence it was actually done
      3. **CRITICAL**: If marked [x] but NOT DONE ‚Üí CRITICAL finding
      4. Record specific proof (file:line)
    </action>

    <!-- Code Quality Deep Dive -->
    <action>For EACH file in comprehensive review list:
      1. **Security**: Look for injection risks, missing validation, auth issues
      2. **Performance**: N+1 queries, inefficient loops, missing caching
      3. **Error Handling**: Missing try/catch, poor error messages
      4. **Code Quality**: Complex functions, magic numbers, poor naming
      5. **Test Quality**: Are tests real assertions or placeholders?
      6. **PEP 20 Compliance** (STYLE_GUIDE.md Section 6):
         - Simplicity: Functions have single purpose, cyclomatic complexity ‚â§ 10
         - Explicitness: No magic numbers, clear parameter names, obvious behavior
         - Readability: Domain concepts use full words, not abbreviations
         - Flatness: Nesting depth ‚â§ 3, early returns preferred
         - Consistency: Follows project patterns (vectorization, type sharing)
      7. **SOLID Principles** (STYLE_GUIDE.md Section 10):
         - SRP: Classes/functions have single responsibility (overlap with PEP 20)
         - OCP: New features via extension (inheritance), not modification
         - LSP: Subtypes honor parent contracts (check return types, behavior)
         - ISP: Interfaces are small (Protocols preferred over fat abstract classes)
         - DIP: Depends on abstractions (Protocols), not concrete implementations
      8. **Functional Design** (STYLE_GUIDE.md Section 6.2):
         - Business logic is pure (deterministic, no I/O, no side effects)
         - Side effects pushed to edges (data loading, saving, orchestration)
         - No mixing of pure logic with I/O operations
         - Pure functions use property-based tests (Hypothesis)
         - Pure functions are vectorized (no loops over DataFrames)
    </action>

    <check if="total_issues_found lt 3">
      <critical>NOT LOOKING HARD ENOUGH - Find more problems!</critical>
      <action>Re-examine code for:
        - Edge cases and null handling
        - Architecture violations
        - Documentation gaps
        - Integration issues
        - Dependency problems
        - Git commit message quality (if applicable)
        - PEP 20 violations (complex functions, implicit behavior, poor naming, deep nesting)
        - SOLID violations (multiple responsibilities, modification instead of extension, fat interfaces, concrete dependencies)
        - Functional design violations (pure logic mixed with I/O, side effects in business logic, non-vectorized calculations)
      </action>
      <action>Find at least 3 more specific, actionable issues</action>
    </check>
  </step>

  <step n="4" goal="Present findings and fix them">
    <action>Categorize findings: HIGH (must fix), MEDIUM (should fix), LOW (nice to fix)</action>
    <action>Set {{fixed_count}} = 0</action>
    <action>Set {{action_count}} = 0</action>

    <output>**üî• CODE REVIEW FINDINGS, {user_name}!**

      **Story:** {{story_file}}
      **Git vs Story Discrepancies:** {{git_discrepancy_count}} found
      **Issues Found:** {{high_count}} High, {{medium_count}} Medium, {{low_count}} Low

      ## üî¥ CRITICAL ISSUES
      - Tasks marked [x] but not actually implemented
      - Acceptance Criteria not implemented
      - Story claims files changed but no git evidence
      - Security vulnerabilities

      ## üü° MEDIUM ISSUES
      - Files changed but not documented in story File List
      - Uncommitted changes not tracked
      - Performance problems
      - Poor test coverage/quality
      - Code maintainability issues

      ## üü¢ LOW ISSUES
      - Code style improvements
      - Documentation gaps
      - Git commit message quality
    </output>

    <ask>What should I do with these issues?

      1. **Fix them automatically** - I'll update the code and tests
      2. **Create action items** - Add to story Tasks/Subtasks for later
      3. **Show me details** - Deep dive into specific issues

      Choose [1], [2], or specify which issue to examine:</ask>

    <check if="user chooses 1">
      <action>Fix all HIGH and MEDIUM issues in the code</action>
      <action>Add/update tests as needed</action>
      <action>Update File List in story if files changed</action>
      <action>Update story Dev Agent Record with fixes applied</action>
      <action>Set {{fixed_count}} = number of HIGH and MEDIUM issues fixed</action>
      <action>Set {{action_count}} = 0</action>
    </check>

    <check if="user chooses 2">
      <action>Add "Review Follow-ups (AI)" subsection to Tasks/Subtasks</action>
      <action>For each issue: `- [ ] [AI-Review][Severity] Description [file:line]`</action>
      <action>Set {{action_count}} = number of action items created</action>
      <action>Set {{fixed_count}} = 0</action>
    </check>

    <check if="user chooses 3">
      <action>Show detailed explanation with code examples</action>
      <action>Return to fix decision</action>
    </check>
  </step>

  <step n="4.5" goal="Capture template learnings for future projects">
    <critical>üéì TEMPLATE LEARNING CAPTURE - Preserve patterns for future projects!</critical>

    <action>Check if template-requirements.md exists at {implementation_artifacts}/template-requirements.md or {planning_artifacts}/template-requirements.md</action>

    <check if="template-requirements.md exists">
      <action>Review changes made in this story for template-worthy patterns:</action>

      **Dev Stack & Dependencies:**
      - New dependencies added (libraries, tools, frameworks)
      - Tool configuration changes (linting, formatting, type checking)
      - Build or deployment configuration updates

      **Testing Patterns:**
      - New testing approaches discovered
      - Test fixtures or utilities created
      - Coverage or quality gate adjustments

      **Architecture Decisions:**
      - New patterns or conventions established
      - Architecture constraints discovered
      - Integration patterns worth preserving

      **Code Quality Standards:**
      - Style guide refinements
      - Naming conventions clarified
      - Best practices discovered

      **Development Workflow:**
      - Process improvements found effective
      - Quality gates that worked well
      - Tooling that improved productivity

      **Lessons Learned:**
      - What worked exceptionally well
      - What didn't work and should be avoided
      - Surprising discoveries or gotchas

      <check if="template learnings identified">
        <output>**üìù Template Learnings Identified:**

        I found {{learning_count}} patterns worth preserving for future projects:

        {{list_learnings_with_categories}}

        **Should I update template-requirements.md?**
        [y] Yes, update now
        [n] No, not applicable
        [l] Let me review the learnings first
        </output>

        <ask>Update template-requirements.md? (y/n/l)</ask>

        <check if="user chooses 'l'">
          <output>**Template Learnings Detail:**

          {{detailed_learning_descriptions}}

          **Update template-requirements.md with these learnings?** (y/n)</output>
          <ask>Proceed with update?</ask>
        </check>

        <check if="user confirms update">
          <action>Read complete template-requirements.md file</action>
          <action>Identify appropriate sections for each learning</action>
          <action>Update relevant sections with new learnings:
            - Add to existing bullet points or create new ones
            - Include reference to this story (e.g., "Discovered in Story {{story_id}}")
            - Add date of discovery
            - Mark items as confirmed patterns vs. experimental
          </action>
          <action>Save updated template-requirements.md</action>
          <output>‚úÖ Template learnings captured in template-requirements.md

          Updated sections:
          {{list_updated_sections}}
          </output>
        </check>

        <check if="user declines update">
          <output>‚è≠Ô∏è Skipping template update - marked as not applicable</output>
        </check>
      </check>

      <check if="no template learnings identified">
        <output>‚ÑπÔ∏è No significant template learnings identified in this story</output>
      </check>
    </check>

    <check if="template-requirements.md does NOT exist">
      <output>‚ÑπÔ∏è Template requirements tracking not configured for this project</output>
    </check>
  </step>

  <step n="5" goal="Update story status and sync sprint tracking">
    <!-- Determine new status based on review outcome -->
    <check if="all HIGH and MEDIUM issues fixed AND all ACs implemented">
      <action>Set {{new_status}} = "done"</action>
      <action>Update story Status field to "done"</action>
    </check>
    <check if="HIGH or MEDIUM issues remain OR ACs not fully implemented">
      <action>Set {{new_status}} = "in-progress"</action>
      <action>Update story Status field to "in-progress"</action>
    </check>
    <action>Save story file</action>

    <!-- Determine sprint tracking status -->
    <check if="{sprint_status} file exists">
      <action>Set {{current_sprint_status}} = "enabled"</action>
    </check>
    <check if="{sprint_status} file does NOT exist">
      <action>Set {{current_sprint_status}} = "no-sprint-tracking"</action>
    </check>

    <!-- Sync sprint-status.yaml when story status changes (only if sprint tracking enabled) -->
    <check if="{{current_sprint_status}} != 'no-sprint-tracking'">
      <action>Load the FULL file: {sprint_status}</action>
      <action>Find development_status key matching {{story_key}}</action>

      <check if="{{new_status}} == 'done'">
        <action>Update development_status[{{story_key}}] = "done"</action>
        <action>Save file, preserving ALL comments and structure</action>
        <output>‚úÖ Sprint status synced: {{story_key}} ‚Üí done</output>
      </check>

      <check if="{{new_status}} == 'in-progress'">
        <action>Update development_status[{{story_key}}] = "in-progress"</action>
        <action>Save file, preserving ALL comments and structure</action>
        <output>üîÑ Sprint status synced: {{story_key}} ‚Üí in-progress</output>
      </check>

      <check if="story key not found in sprint status">
        <output>‚ö†Ô∏è Story file updated, but sprint-status sync failed: {{story_key}} not found in sprint-status.yaml</output>
      </check>
    </check>

    <check if="{{current_sprint_status}} == 'no-sprint-tracking'">
      <output>‚ÑπÔ∏è Story status updated (no sprint tracking configured)</output>
    </check>

    <!-- CREATE PULL REQUEST -->
    <action tag="git-workflow">Create pull request for the story branch</action>

    <action>Check if current branch follows story branch pattern: story/{{epic}}-{{story}}-{{slug}}</action>
    <action>Get current branch name using: git branch --show-current</action>
    <action>Store as {{current_branch}}</action>

    <check if="{{current_branch}} matches story/* pattern">
      <action>Check if gh CLI is available: gh --version</action>

      <check if="gh CLI available">
        <action>Get commits on the story branch not in main using: git log main..{{current_branch}} --oneline</action>
        <action>Store commit count and list</action>

        <check if="commits exist on story branch">
          <action>Push branch to remote if not already pushed: git push -u origin {{current_branch}}</action>

          <action>Generate PR title from story (max 70 chars):
            - Format: Brief summary of story goal
            - Example: "Add testing strategy documentation"
          </action>

          <action>Generate PR body following .github/pull_request_template.md format:

            ## PR Type
            - Identify type from story: Documentation update, New feature, Bugfix, etc.

            ## Description
            - Summary of what PR does and why (from story description)
            - Link to story file: [story-file.md](_bmad-output/implementation-artifacts/story-file.md)
            - Bullet points of key deliverables from File List

            ## Expected behavior
            - Describe what should work after this change (from Acceptance Criteria)

            ## Steps to reproduce the behavior
            - For features/bugs: steps to verify the change works
            - For docs: how to use the new documentation

            ## Supporting Evidence
            - **Acceptance Criteria Coverage:**
              - List each AC with [x] or [ ] based on implementation
            - **Files Created/Modified:** List from story File List

            ## Pre-Commit Checks
            - [x] All applicable pre-commit checks with status
            - Mark N/A for documentation-only or non-applicable checks

            ## Test Suite
            - [x] Test suite status
            - Mark N/A for documentation-only changes

            ## Code Quality
            - [x] Code quality checks with status
            - Mark N/A for documentation-only changes

            ## Architecture Compliance
            - [x] Architecture compliance checks
            - Note any new dependencies added

            ## Documentation
            - [x] Documentation update status
            - Note visual-first compliance for user-facing docs

            ## Template Learning Capture
            - [x] If template learnings captured, mark as done
            - [ ] N/A if no template patterns

            ## Related Issue
            - Reference to Epic/Story

            ---

            **Code Review Notes:**
            - {{fixed_count}} issues fixed during code review
            - {{action_count}} action items created (if any)
            - List key fixes applied

            ü§ñ Generated with [Claude Code](https://claude.com/claude-code)
          </action>

          <action>Create PR WITHOUT custom body to use template: gh pr create --title "{{pr_title}}"</action>
          <action>NOTE: This will open editor with template - agent should fill it programmatically using gh pr edit instead</action>
          <action>ALTERNATIVE: Use gh pr create --title "{{pr_title}}" --body "{{pr_body_formatted}}" with template-formatted body</action>
          <action>Capture PR URL from command output</action>
          <action>Store as {{pr_url}}</action>

          <output>üéâ Pull request created: {{pr_url}}</output>
        </check>

        <check if="no commits on story branch">
          <output>‚ÑπÔ∏è No commits found on story branch - PR creation skipped</output>
        </check>
      </check>

      <check if="gh CLI not available">
        <output>‚ö†Ô∏è GitHub CLI (gh) not installed - PR creation skipped
          To install: https://cli.github.com/
        </output>
      </check>
    </check>

    <check if="{{current_branch}} does NOT match story/* pattern">
      <output>‚ÑπÔ∏è Not on a story branch ({{current_branch}}) - PR creation skipped</output>
    </check>

    <output>**‚úÖ Review Complete!**

      **Story Status:** {{new_status}}
      **Issues Fixed:** {{fixed_count}}
      **Action Items Created:** {{action_count}}
      {{#if pr_url}}**Pull Request:** {{pr_url}}{{/if}}

      {{#if new_status == "done"}}Code review complete!{{else}}Address the action items and continue development.{{/if}}
    </output>
  </step>

</workflow>
